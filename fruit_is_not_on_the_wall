import sys
import math
import pygame
import random
import numpy as np
import heapq as hq
from sys import exit


pygame.init()
screen = pygame.display.set_mode((800, 600))
pygame.display.set_caption('AI powered Snake Game')

# A* section
class Block:
    def __init__(self, i, j):
        self.i = i
        self.j = j
        self.parent_i = -1
        self.parent_j = -1
        self.g = 0
        self.h = math.inf
        self.f = math.inf

    def calculate_h(self, fruit_pos):
        return abs(self.i- fruit_pos[0]) + abs(self.j-fruit_pos[1])
    
    def __lt__(self, next):
        if self.f == next.f:
            return self.g > next.g
        return self.f < next.f


def grid_def(body):
    board = np.zeros((15, 20))
    for block in body[1:]:
        i= int(block[1]/40)
        j= int(block[0]/40)
        board[i, j] = 1
    if wall_pos:
        for j in range(len(wall_pos)):
            (a, b) = wall_pos[j]
            board[int(b / 40), int(a / 40)] = 1
    return board
    

def A_alg(body, fruit_pos, board):
    head= Block(int(body[0][1]/40) , int(body[0][0]/40))
    head.f= 0
    fruit_pos= (int(fruit_pos[1]/40), int(fruit_pos[0]/40))

    open_list=[]
    hq.heappush(open_list, (head.f, head))
    closed_list=[[False for i in range (20)] for j in range(15)]
    grid = [[ None for i in range (20)] for j in range(15)]
    grid[head.i][head.j]= head 

    while open_list:
        q= hq.heappop(open_list)[1]
        i, j= q.i, q.j
        closed_list[i][j] = True

        directions= [(1,0), (-1,0), (0,1), (0,-1)]
        for dir in directions:
            succ_i, succ_j = i + dir[0] , j + dir[1]

            if 0<= succ_i < 15 and 0<= succ_j <20 and not closed_list[succ_i][succ_j] and board[succ_i, succ_j] == 0:
                succ= Block(succ_i, succ_j)
                succ.parent_i, succ.parent_j = i, j
                succ.g = q.g + 1
                succ.h = succ.calculate_h(fruit_pos)
                succ.f = succ.g + succ.h

                if (succ_i, succ_j) == fruit_pos:
                    grid[succ_i][succ_j] = succ
                    return grid
                
                else:
                    if grid[succ_i][succ_j] == None or grid[succ_i][succ_j].f > succ.f:
                        hq.heappush(open_list, (succ.f, succ))
                        grid[succ_i][succ_j] = succ

    return None


def path(grid,fruit_pos):
    fruit_pos_x, fruit_pos_y = int(fruit_pos[1]/40), int(fruit_pos[0]/40)
    path= []
    if grid is None:
        return []
    else:
        current = grid[fruit_pos_x][fruit_pos_y]
        while current.g != 0:
            new_i= current.parent_i
            new_j= current.parent_j
            path.append((new_j, new_i))
            current=grid[new_i][new_j]
        path.reverse()
        path.append((fruit_pos_y, fruit_pos_x))
        return path

def show_path(path):
    for i,sq in enumerate(path[1:]):
        color=(150,10,150)
        tile= pygame.Surface((40,40))
        tile.fill(color)
        tile.set_alpha(65)
        screen.blit(tile, (sq[0]*40,sq[1]*40))

def go_around(body, current_dir):
    head = body[0]
    directions = {'left': (-40, 0), 'right': (40, 0), 'up': (0, -40), 'down': (0, 40)}
    opposite_dir = {(-40, 0): (40, 0), (40, 0): (-40, 0), (0, -40): (0, 40), (0, 40): (0, -40)}
    valid_dirs = {name: dir for name, dir in directions.items() if dir != opposite_dir[current_dir]}

    free_space = {}
    for name, dir in valid_dirs.items():
        count = 0
        curr_x, curr_y = head
        while 0 <= curr_x < 800 and 0 <= curr_y < 600:
            curr_x += dir[0]
            curr_y += dir[1]
            if (curr_x, curr_y) in body or (curr_x, curr_y) in wall_pos:
                break
            count += 1
        free_space[name] = count

    best_direction = max(free_space, key=free_space.get)
    return directions[best_direction]

class Fruit:
    def __init__(self, chosen_fruit, score, position):
        self.chosen = chosen_fruit
        self.score = score
        self.pos = pygame.math.Vector2(position[0], position[1])
        self.image = pygame.image.load(f'pics\\{self.chosen}.png').convert_alpha()
        self.image = pygame.transform.scale(self.image, (40,40))

    def draw_fruit(self):
        fruit_rect = self.image.get_rect(topleft=self.pos)
        screen.blit(self.image, fruit_rect)

class Snake:
    def __init__(self):
        self.body = [pygame.math.Vector2(5, 13) * 40, pygame.math.Vector2(6, 13) * 40, pygame.math.Vector2(7, 13) * 40]
        self.direction = pygame.math.Vector2(-40, 0)
        self.color = (0, 153, 255)
        self.new_block = False
        self.mouth_open = True
        self.mouth_timer = 0    

    def close_mouth(self):
        self.mouth_open = False
        self.mouth_timer = pygame.time.get_ticks()

    def update_mouth(self):       
        if not self.mouth_open:
            curr_time = pygame.time.get_ticks()
            if curr_time - self.mouth_timer > 400:
                self.mouth_open = True 

    def draw_snake(self):
        for i,block in enumerate(self.body):
            if i==0:
                if self.mouth_open:
                    head = pygame.image.load("pics\\open_mouth.png")
                else:
                    head = pygame.image.load("pics\\closed_mouth.png")
                head = pygame.transform.flip(head, True, False)
                head=pygame.transform.scale(head, (38, 38))										
                directions={(-40, 0):(0,0),(40, 0):(1,0),(0,-40):(0,0),(0, 40):(0,0)}
                head = pygame.transform.flip(head, directions[tuple(self.direction)][0], directions[tuple(self.direction)][1])
                if tuple(self.direction)==(0, 40):
                    head=pygame.transform.rotate(head,90)
                if tuple(self.direction)==(0, -40):
                    head=pygame.transform.rotate(head,-90)
                head_rect = head.get_rect(topleft = block + (1,1))
                screen.blit(head, head_rect)
            elif i==len(self.body)-1:
                tail=pygame.image.load("pics\\tail1.png")
                tail = pygame.transform.flip(tail, True, False)
                tail=pygame.transform.scale(tail, (38, 38))
                tail_rect=tail.get_rect(topleft = block + (1,1))
                last_block=tuple(self.body[i-1])
                dx=last_block[0]-block[0]
                dy=last_block[1]-block[1]
                if dx:
                    if dx>0:
                       tail = pygame.transform.flip(tail,1,0)
                else:
                    if dy>0:
                        tail=pygame.transform.rotate(tail,90) 
                    else:
                        tail=pygame.transform.rotate(tail,-90)
                screen.blit(tail, tail_rect)
            else:    
                snake_block = pygame.Surface((40,40))
                snake_block.fill("antiquewhite")
                snake_block = pygame.transform.scale(snake_block, (40, 40))
                snake_block_rect = snake_block.get_rect(topleft = block)
                screen.blit(snake_block, snake_block_rect)
                border_rect = snake_block_rect.inflate(-2, -2)  
                pygame.draw.rect(screen, self.color, border_rect)

    def move_snake(self):
        if self.new_block:
            body_copy = self.body[:]
            body_copy.insert(0, body_copy[0] + self.direction)
            self.body = body_copy[:]
            self.new_block = False
        else:
            body_copy = self.body[:-1] # we dont need the last block of snake
            body_copy.insert(0, body_copy[0] + self.direction) # moving head
            self.body = body_copy[:]

    def add_block(self):
        self.new_block = True

class MAIN:

    def __init__(self, fruit_scores, wall_pos=[]):
        self.snake = Snake()
        self.fruit_scores = fruit_scores
        self.fruits = []
        self.fruit_number=1
        self.wall_pos=wall_pos

    def fruits_generation(self):
        self.fruits=[]
        for i in range(self.fruit_number):
            chosen_fruit = random.choice(list(fruit_scores.keys()))
            score = fruit_scores[chosen_fruit]
            while True:
                fruit_possible_pos = (random.randint(0, 19) * 40, random.randint(0, 14) * 40)
                if fruit_possible_pos not in [tuple(block) for block in self.snake.body] and fruit_possible_pos not in self.wall_pos and fruit_possible_pos not in [fruit.pos for fruit in self.fruits]:
                    break

            self.fruits.append(Fruit(chosen_fruit, score, fruit_possible_pos))

    def update(self):
        self.snake.move_snake()
        self.collision_head()
        self.check_game_over()

    def draw_elements(self):
        self.snake.draw_snake()
        for fruit in self.fruits:
            fruit.draw_fruit()

    def collision_head(self):
        global score, inst_score , bite_sound, col_time
        for fruit in self.fruits[:]:
            if fruit.pos == self.snake.body[0]:
                col_time=pygame.time.get_ticks()
                bite_sound.play()
                score += fruit.score
                self.fruits.remove(fruit)
                inst_score = (True, fruit.score, None, None)
                self.snake.close_mouth()
                while True:
                    fruits_pos = [self.fruits[self.fruits.index(fruit)].pos for fruit in self.fruits]
                    possible_pose = (random.randint(0, 19) * 40, random.randint(0, 14) * 40)
                    if possible_pose not in self.snake.body and possible_pose not in fruits_pos and possible_pose not in self.wall_pos:
                        break
                new_chosen_fruit = random.choice(list(self.fruit_scores.keys()))
                new_fruit = Fruit(new_chosen_fruit, self.fruit_scores[new_chosen_fruit], possible_pose)
                self.fruits.append(new_fruit)
                self.snake.add_block()
                break

    def random_fruits(self):
        chosen_fruit = random.choice(list(self.fruit_scores.keys()))
        return Fruit(chosen_fruit=random.choice(list(self.fruit_scores.keys())),
                score=self.fruit_scores[chosen_fruit],
                fruit_image=self.fruit_images[chosen_fruit])

    def check_game_over(self):
        if self.snake.body[0].x <= -40 or self.snake.body[0].x >= 800 or self.snake.body[0].y <= -40 or self.snake.body[0].y >= 600:
            self.game_over()
        head_block = pygame.Surface((40,40))
        head_block_rect = head_block.get_rect(topleft = self.snake.body[0])        
        for block in self.snake.body[1:]:
            snake_block = pygame.Surface((40,40))
            snake_block_rect = snake_block.get_rect(topleft = block)
            if head_block_rect.colliderect(snake_block_rect) :
                self.game_over()

        for block in self.wall_pos:
            wall_block = pygame.Surface((40,40))
            wall_block_rect = wall_block.get_rect(topleft = block)
            if head_block_rect.colliderect(wall_block_rect) :
                self.game_over()
    
    def updating_high_scores(self):
        with open("leader_board.txt",'w') as f:
            f.write(str(ai_score) + '\n')
            f.write(str(hu_score) + '\n')
                
    def game_over(self):
        global game_state , game_over_sound, ai_score, hu_score
        game_over_sound.play()
        game_state= 'game over'
        if automation=='automatic':
            if ai_score:
                if score> ai_score:
                    ai_score=score
                    self.updating_high_scores()
            else:
                ai_score=score
                self.updating_high_scores()
        if automation=='manual':
            if hu_score:
                if score> hu_score:
                    hu_score=score
                    self.updating_high_scores()
            else:
                hu_score=score
                self.updating_high_scores()
        
        

def draw_wall():
    h_or_v = [random.randint(0, 1) for k in range(2)]
    wall_pos = []
    for j in range(2):
        if h_or_v[j] == 0:
            while True:
                wall_possible_pos_x = random.randint(2, 19) * 40
                wall_possible_pos_y = random.randint(2, 14) * 40
                if (wall_possible_pos_x, wall_possible_pos_y) not in [pygame.math.Vector2(5, 13) * 40, pygame.math.Vector2(6, 13) * 40, pygame.math.Vector2(7, 13) * 40]:
                    break
            wall_pos.append((wall_possible_pos_x, wall_possible_pos_y))
            wall_pos.append((wall_possible_pos_x - 40, wall_possible_pos_y))
            wall_pos.append((wall_possible_pos_x - 80, wall_possible_pos_y))
        if h_or_v[j] == 1:
            while True:
                wall_possible_pos_x = random.randint(2, 19) * 40
                wall_possible_pos_y = random.randint(2, 14) * 40
                if (wall_possible_pos_x, wall_possible_pos_y) not in [pygame.math.Vector2(5, 13) * 40, pygame.math.Vector2(6, 13) * 40, pygame.math.Vector2(7, 13) * 40]:
                    break
            wall_pos.append((wall_possible_pos_x, wall_possible_pos_y))
            wall_pos.append((wall_possible_pos_x, wall_possible_pos_y - 40))
            wall_pos.append((wall_possible_pos_x, wall_possible_pos_y - 80))
    return wall_pos


def draw_walls_on_surface(wall_pos):
    if not wall_pos:
        return
    for i in range(len(wall_pos)):
        wall_image = pygame.image.load("pics\\tree.png")
        wall_image = pygame.transform.scale(wall_image, (40, 40))
        wall_rect = wall_image.get_rect(topleft=wall_pos[i])
        screen.blit(wall_image, wall_rect)

fruit_scores = {"a_banana": 2, "cucumber": 1, "apple": 3, "grapes": 5, "mango": 7, "3 bananas": 6, "blueberry": 8,
                "strawberry": 9, "pomegranate": 10, 'watermelon': 12, 'pineapple': 15, 'fig': 4}

def game_grid():
    for i in range(40,800,40):
        pygame.draw.aaline(screen,'bisque3',(i,0),(i,600))
    for j in range(40,600,40):
        pygame.draw.aaline(screen,'bisque3',(0,j),(800,j))


clock = pygame.time.Clock()
AUTO_MOVE_EVENT = pygame.USEREVENT + 1
pygame.time.set_timer(AUTO_MOVE_EVENT, 225)
screen_input = pygame.USEREVENT
pygame.time.set_timer(screen_input, 225)
game_state= 'main menu'
automation='automatic'
score= 0
# collision occurunce, current fruit score, time passed since score appearance and current score position are saved in inst_score
inst_score = (False, None, None, None)

pygame.mixer.init()
bg_music_channel = pygame.mixer.Channel(0)
game_music_channel = pygame.mixer.Channel(1)
bg_music= pygame.mixer.Sound('music\\bg music.mp3')
game_music= pygame.mixer.Sound('music\\game music.wav')
bite_sound= pygame.mixer.Sound('music\\bite sound.mp3')
game_over_sound= pygame.mixer.Sound('music\\game over sound.mp3')
ui_click= pygame.mixer.Sound('music\\ui-click-43196.mp3')
ui_click.set_volume(10.0)

def music():
    global bg_music , game_music , bg_music_channel , game_music_channel

    if game_state == 'main menu' and not bg_music_channel.get_busy():
        game_music_channel.stop()
        bg_music_channel.play(bg_music, -1)
        
    elif game_state == 'in game' and not game_music_channel.get_busy():
        bg_music_channel.stop()
        game_music_channel.play(game_music, -1)

    elif game_state == 'pause' or game_state == 'game over':
        game_music_channel.stop()


font_0= pygame.font.SysFont('arial', 30)
font_1= pygame.font.SysFont('arial', 40)
font_2= pygame.font.SysFont('arial', 70)
font_3= pygame.font.SysFont('arial', 20)
chose_button = pygame.image.load('pics\\chosen_button.png').convert_alpha()
button = pygame.image.load('pics\\not_chosen_button.png').convert_alpha()


def draw_background():
    back_ground = pygame.image.load("pics\\cute_snake.jpg")
    back_ground = pygame.transform.scale(back_ground, (800, 600))
    back_ground_rect=back_ground.get_rect(topleft = (0,0))
    screen.blit(back_ground,back_ground_rect)

def restart_conditions():
    global score , game_state
    score=0
    game_state = 'in game'
    main_game.fruits_generation()
    main_game.snake.body = [pygame.math.Vector2(5, 13) * 40, pygame.math.Vector2(6, 13) * 40, pygame.math.Vector2(7, 13) * 40]
    main_game.snake.direction = pygame.math.Vector2(-40, 0)

def display_score(score):
    score_text= font_0.render(f'score: {score}', False, 'aquamarine4')
    score_rect= score_text.get_rect(topleft=(5,0))
    screen.blit(score_text, score_rect)

def instant_score(score):
    global inst_score
    if inst_score[0]:
        current_time = pygame.time.get_ticks()

        if inst_score[2] is None:
            head_pos= tuple(main_game.snake.body[0])
            if head_pos[1] == 0:
                score_pos= (head_pos[0], head_pos[1] + 40)
            else:
                score_pos= (head_pos[0], head_pos[1]-40)
            inst_score = (True, inst_score[1], current_time, score_pos)

        if current_time - inst_score[2] < 400:
            instant_score_text= font_3.render(f'+{score}', False, 'Black')
            instant_score_rect= instant_score_text.get_rect(topleft= inst_score[3])
            screen.blit(instant_score_text, instant_score_rect)
        else:
            inst_score = (False, None, None, None)

def game_over_page():
    global button , chose_button
    # showing game over text
    game_over_text= font_2.render('Game Over', False, 'Black')
    game_over_rect= game_over_text.get_rect(midtop=(400, 50))
    screen.blit(game_over_text, game_over_rect)
    
	# drawing the main_menu button
    button_menu = pygame.transform.scale(button, (200, 50))
    button_menu_rect = button_menu.get_rect(midtop=(400, 500))
    screen.blit(button_menu, button_menu_rect)
    main_menu_text= font_1.render('Main Menu', False, 'Black')
    main_menu_rect= main_menu_text.get_rect(midtop=(400, 500))
    screen.blit(main_menu_text, main_menu_rect)

    #drwaing the score rect
    button_score = pygame.transform.scale(button, (150, 50))
    button_score_rect = button_score.get_rect(midtop=(400, 400))
    screen.blit(button_score, button_score_rect)
    score_text= font_1.render(f'Score= {score}', False, 'Black')
    score_rect= score_text.get_rect(midtop=(400, 400))
    screen.blit(score_text, score_rect)

    #drwaing the high_score rect
    button_human = pygame.transform.scale(button, (360, 50))
    button_human_rect = button_human.get_rect(midtop=(400, 250))
    screen.blit(button_human, button_human_rect)
    score_text= font_1.render(f'Human High Score= {hu_score}', False, 'Black')
    score_rect= score_text.get_rect(midtop=(400, 250))
    screen.blit(score_text, score_rect)

    button_ai = pygame.transform.scale(button, (300, 50))
    button_ai_rect = button_ai.get_rect(midtop=(400, 150))
    screen.blit(button_ai, button_ai_rect)
    score_text= font_1.render(f'AI High Score= {ai_score}', False, 'Black')
    score_rect= score_text.get_rect(midtop=(400, 150))
    screen.blit(score_text, score_rect)

    return main_menu_rect
    
def main_page():
    global button
    # drawing the restart button
    button_start = pygame.transform.scale(button, (90, 50))
    button_start_rect = button_start.get_rect(midtop=(400, 75))
    screen.blit(button_start, button_start_rect)
    start_text= font_1.render('Start', False, 'Black')
    start_rect= start_text.get_rect(midtop=(400, 75))
    screen.blit(start_text, start_rect)

    # drawing the options button
    button_opt = pygame.transform.scale(button, (230, 50))
    button_opt_rect = button_opt.get_rect(midtop=(400, 175))
    screen.blit(button_opt, button_opt_rect)
    game_options_text= font_1.render('Game Options', False, 'Black')
    game_options_rect= game_options_text.get_rect(midtop=(400, 175))
    screen.blit(game_options_text, game_options_rect)

    #drawing the exit button
    button_exit = pygame.transform.scale(button, (80, 50))
    button_exit_rect = button_exit.get_rect(midtop=(400, 275))
    screen.blit(button_exit, button_exit_rect)
    exit_text= font_1.render('Exit', False, 'Black')
    exit_rect= exit_text.get_rect(midtop=(400, 275))
    screen.blit(exit_text, exit_rect)

    return start_rect, exit_rect, game_options_rect

def pause():
    global button
    box = pygame.Surface((240, 480))
    box.fill('cadetblue3')
    box_rect = box.get_rect(midtop= (400, 80))
    screen.blit(box, box_rect)

    #restart button
    button_res = pygame.transform.scale(button, (120, 50))
    button_res_rect = button_res.get_rect(midtop=(400, 240))
    screen.blit(button_res, button_res_rect)
    restart_text= font_1.render('Restart', False, 'Black')
    restart_rect= restart_text.get_rect(midtop=(400, 240))
    screen.blit(restart_text, restart_rect)

    #resume_button
    button_resu = pygame.transform.scale(button, (140, 50))
    button_resu_rect = button_resu.get_rect(midtop=(400, 120))
    screen.blit(button_resu, button_resu_rect)
    resume_text= font_1.render('Resume', False, 'Black')
    resume_rect= resume_text.get_rect(midtop=(400, 120))
    screen.blit(resume_text, resume_rect)

    #main menu
    button_main = pygame.transform.scale(button, (180, 50))
    button_main_rect = button_main.get_rect(midtop=(400, 360))
    screen.blit(button_main, button_main_rect)
    menu_text= font_1.render('Main Menu', False, 'Black')
    menu_rect= menu_text.get_rect(midtop=(400, 360))
    screen.blit(menu_text, menu_rect)

    # exit
    button_ex = pygame.transform.scale(button, (80, 50))
    button_ex_rect = button_ex.get_rect(midtop=(400, 480))
    screen.blit(button_ex, button_ex_rect)
    exit2_text= font_1.render('Exit', False, 'Black')
    exit2_rect= exit2_text.get_rect(midtop=(400, 480))
    screen.blit(exit2_text, exit2_rect)

    return restart_rect, resume_rect, menu_rect, exit2_rect

def game_options(ch1,ch2,ch3):

    colors=[chose_button,button]
    #mono_fruit, multi_fruit
    button_mono = pygame.transform.scale(colors[ch1], (190, 50))
    button_mono_rect = button_mono.get_rect(midtop=(285, 50))
    screen.blit(button_mono, button_mono_rect)
    mono_fruit_text= font_1.render('Mono Fruit', False, 'Black')
    mono_fruit_rect= mono_fruit_text.get_rect(midtop=(285, 50))
    screen.blit(mono_fruit_text, mono_fruit_rect)

    button_multi = pygame.transform.scale(colors[int(1-ch1)], (190, 50))
    button_multi_rect = button_multi.get_rect(midtop=(485, 50))
    screen.blit(button_multi, button_multi_rect)
    multi_fruit_text= font_1.render('Multi Fruit', False, 'Black')
    multi_fruit_rect= multi_fruit_text.get_rect(midtop=(485, 50))
    screen.blit(multi_fruit_text, multi_fruit_rect)

    #with_wall , without_wall
    button_wall = pygame.transform.scale(colors[ch2], (190, 50))
    button_wall_rect = button_wall.get_rect(midtop=(285, 125))
    screen.blit(button_wall, button_wall_rect)
    with_wall_text= font_1.render('With Wall', False, 'Black')
    with_wall_rect= with_wall_text.get_rect(midtop=(285, 125))
    screen.blit(with_wall_text, with_wall_rect)

    button_biwall = pygame.transform.scale(colors[int(1-ch2)], (190, 50))
    button_biwall_rect = button_biwall.get_rect(midtop=(485, 125))
    screen.blit(button_biwall, button_biwall_rect)
    without_wall_text= font_1.render('Without Wall', False, 'Black')
    without_wall_rect= without_wall_text.get_rect(midtop=(485, 125))
    screen.blit(without_wall_text, without_wall_rect)

    #automatic, manual
    button_aut = pygame.transform.scale(colors[ch3], (190, 50))
    button_aut_rect = button_aut.get_rect(midtop=(285, 200))
    screen.blit(button_aut, button_aut_rect)
    automatic_text= font_1.render('Automatic', False, 'Black')
    automatic_rect= automatic_text.get_rect(midtop=(285, 200))
    screen.blit(automatic_text, automatic_rect)

    button_man = pygame.transform.scale(colors[int(1-ch3)], (190, 50))
    button_man_rect = button_man.get_rect(midtop=(485, 200))
    screen.blit(button_man, button_man_rect)
    manual_text= font_1.render('Manual', False, 'Black')
    manual_rect= manual_text.get_rect(midtop=(485, 200))
    screen.blit(manual_text, manual_rect)

    # drawing the start button
    button_str = pygame.transform.scale(button, (150, 50))
    button_str_rect = button_str.get_rect(midtop=(400, 275))
    screen.blit(button_str, button_str_rect)
    start_text= font_1.render('Start', False, 'Black')
    start_rect= start_text.get_rect(midtop=(400, 275))
    screen.blit(start_text, start_rect)

    return mono_fruit_rect, multi_fruit_rect, with_wall_rect, without_wall_rect, automatic_rect, manual_rect, start_rect



main_game=MAIN(fruit_scores)
ch1,ch2,ch3=0,1,0

with open("leader_board.txt",'r+') as f:
    #the first line is for ai high score and the second one is for human
    try:
        ai_score= int(f.readline().rstrip())
        hu_score= int(f.readline().rstrip())
    except:
        ai_score=0
        hu_score=0


# the game loop
while True:

    
    # exit code
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            exit()
        

        # displaying the main menu
        if game_state == 'main menu':

            # draing the background and main menu options 
            draw_background()
            start_rect, exit_rect, game_options_rect= main_page()

            if event.type == pygame.MOUSEBUTTONDOWN:

                #restarting the game
                if start_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    restart_conditions()

                #exiting the game
                elif exit_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    pygame.quit()
                    exit()

                #options
                elif game_options_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    game_state = 'options'
            


        # displaying the options menu
        elif game_state =='options':
            
            #drawing the background and game options
            draw_background()
            mono_fruit_rect, multi_fruit_rect, with_wall_rect, without_wall_rect, automatic_rect, manual_rect, start_rect = game_options(ch1,ch2,ch3)
            
            # applying various options to the game
            if event.type == pygame.MOUSEBUTTONDOWN:

                if mono_fruit_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    main_game.fruit_number=1
                    ch1=0

                elif multi_fruit_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    main_game.fruit_number=3
                    ch1=1

                elif with_wall_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    main_game.wall_pos = draw_wall()
                    ch2=0

                elif without_wall_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    main_game.wall_pos=[]
                    ch2=1

                elif automatic_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    automation='automatic'
                    ch3=0

                elif manual_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    automation='manual'
                    ch3=1

                elif start_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    restart_conditions()



        # going into the game
        elif game_state == 'in game':
            
            # drawing game elements on the screen
            screen.fill("antiquewhite")
            draw_walls_on_surface(main_game.wall_pos)
            game_grid()
            main_game.snake.update_mouth()
            main_game.draw_elements()


            # display pause button
            pause_button= pygame.image.load('pics\\pause-button.png')
            pause_button= pygame.transform.scale(pause_button, (40, 40))
            pause_rect= pause_button.get_rect(topright= (800, 0))
            screen.blit(pause_button, pause_rect)

            if event.type == pygame.MOUSEBUTTONDOWN and pause_rect.collidepoint(pygame.mouse.get_pos()):
                ui_click.play()
                game_state = 'pause'

            # display total and instant scores
            display_score(score)
            instant_score(inst_score[1])

            wall_pos=main_game.wall_pos

            #path finding

            body=[tuple(i) for i in main_game.snake.body]
            board= grid_def(body)

            # finding all possible paths to all fruits and choosing the best fruit 
            all_path = [path(A_alg(body, fruit.pos, board), fruit.pos) for fruit in main_game.fruits]
            relative_scores = [main_game.fruits[i].score / len(all_path[i]) if all_path[i] else -math.inf for i in range(len(main_game.fruits))]
            best_fruit = main_game.fruits[relative_scores.index(max(relative_scores))]

            # showing the path to the best fruit
            grid = A_alg(body, best_fruit.pos, board)
            found_path = path(grid, best_fruit.pos)

            if found_path and event.type!= pygame.KEYDOWN:
                show_path(found_path)

            # settig up the manual game state    
            if automation=='manual':
                if event.type == screen_input:
                    main_game.update()
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_UP and main_game.snake.direction != (0, 40):
                        main_game.snake.direction = (0, -40)
                    if event.key == pygame.K_DOWN and main_game.snake.direction != (0, -40):
                        main_game.snake.direction = (0, 40)
                    if event.key == pygame.K_RIGHT and main_game.snake.direction != (-40, 0):
                        main_game.snake.direction = (40, 0)
                    if event.key == pygame.K_LEFT and main_game.snake.direction != (40, 0):
                        main_game.snake.direction = (-40, 0)
            
            # setting up the automatic game state
            elif automation=='automatic':
                if event.type == AUTO_MOVE_EVENT:
                    main_game.update()

                if found_path :
                    if len(found_path) > 1:
                        tile=found_path[1]
                        head_x, head_y= body[0][0], body[0][1]
                        main_game.snake.direction= (tile[0]*40 - head_x, tile[1]*40 - head_y)
                    else:
                        main_game.snake.direction = go_around(body, main_game.snake.direction)
                elif not found_path:
                    main_game.snake.direction = go_around(body, main_game.snake.direction)



        
        # game over page
        elif game_state == 'game over':
            main_menu_rect= game_over_page()
            if event.type == pygame.MOUSEBUTTONDOWN and main_menu_rect.collidepoint(pygame.mouse.get_pos()):
                ui_click.play()
                game_state = 'main menu'



        # pause page
        elif game_state == 'pause':
            restart_rect, resume_rect, menu_rect, exit2_rect = pause()

            if event.type == pygame.MOUSEBUTTONDOWN:

                if menu_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play() 
                    game_state= 'main menu'
                
                elif restart_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    restart_conditions()
                
                elif resume_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    game_state= 'in game'
                
                elif exit2_rect.collidepoint(pygame.mouse.get_pos()):
                    ui_click.play()
                    pygame.quit()
                    exit()
    music()
    clock.tick(60)
    pygame.display.update()
